## 责任链设计模式

### 表述

+ 这种模式将接收者对象连成一条链，并在该链上传递请求，直到有一个接收者对象处理它。
+ 这种模式通过让更多的对象有机会处理请求，避免了请求者和接收者之间的耦合。
+ 处理者链和处理者都是抽象和动态的，请求者并不知道处理者怎么变，只要拿到接口就行了，这就是解耦

### 应用场景举例

+ 一个销售大楼，客户要求x%的折扣，售楼小姐由有5%折扣的权限，大于5%问销售经理，销售经理处理5%-30%的折扣，大于30%又去问上一级领导......
+ 解耦体现在：如果要增加一种handler叫Leader处理5%-15%的折扣，只需要在handler包中新建这个类，再改一下工厂方法中的后继依赖关系( sales -> leader -> manager )     而对于客户端Customer而言，不需要做任何改动，这就好比销售大楼新增一个职位，然后顾客不需要管一样
+ 现实场景举例：
  + Java的异常抛出处理机制
  + js的事件模型的冒泡阶段就是dom树上的责任链（cpature捕获阶段-target阶段-bubbling冒泡阶段）
  + JavaEE开发中的filterChain+doFilter()、express/koa2的路由+next() 都是不纯的请求的责任链设计模式（一个请求可能有多个处理者，原则上应该只有一个）

### 优势与缺陷

+ 从面向对象的开闭原则考虑
  + 即对扩展开放，对修改关闭，鼓励新建一个类来扩展业务，而非修改原来的类
  + 比如新增Leader类是符合开闭原则的 但是我们还要修改工厂方法，这是不符合开闭原则的
+ 性能
  + 相对于一对一，一对“责任链”在时间和空间上都不划算 不适合内存密集的应用场景
    + JAVA的AWT早期就是用责任链设计模式来实现事件处理机制  后来换成了观察者模式
  + 需要需要根据业务的情景选择